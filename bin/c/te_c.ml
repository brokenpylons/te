open Te_bot
open Te_core
module T = Types

module X = Spec.Build(functor(Context: Spec.CONTEXT) -> struct
  open Context

  let Vector.[
      start;
      ws;

      ident;
      string;
      char;
      integer;
      unsigned;
      long;
      unsignedlong;
      hexadecimal;
      hexunsigned;
      hexlong;
      hexunslong;
      octal;
      octalunsigned;
      octallong;
      octalunslong;
      double;
      float;
      longdouble;
      type_void;
      type_char;
      type_short;
      type_int;
      type_long;
      type_float;
      type_double;
      type_signed;
      type_unsigned;
      type_typedef;
      typedef;
      extern;
      static;
      auto;
      register;
      const;
      volatile;
      struct_;
      union;
      enum;
      case;
      default;
      if_;
      else_;
      switch;
      while_;
      do_;
      for_;
      goto;
      continue;
      break;
      return;
      sizeof;
      ternary_if;
      ternary_else;
      address;
      indirection;
      pointer;
      bitcomp;
      lneg;
      semi;
      lparen;
      rparen;
      comma;
      lbrace;
      rbrace;
      colon;
      lbrak;
      rbrak;
      assign;
      plus_;
      minus;
      ellip;
      bor;
      band;
      lor_;
      land_;
      bxor;
      eq;
      noteq;
      lt;
      gt;
      gte;
      lte;
      lshift;
      rshift;
      times;
      div;
      rem;
      plusplus;
      minusminus;
      dot;
      arrow;
      timesassign;
      divassign;
      remassign;
      plusassign;
      minusassign;
      lshiftassign;
      rshiftassign;
      landassign;
      lxorassign;
      lorassign;

      program;
      list_external_declaration;
      external_declaration;
      function_def;
      dec;
      list_dec;
      list_declaration_specifier;
      declaration_specifier;
      list_init_declarator;
      init_declarator;
      type_specifier;
      storage_class_specifier;
      type_qualifier;
      struct_or_union_spec;
      struct_or_union;
      list_struct_dec;
      struct_dec;
      list_spec_qual;
      spec_qual;
      list_struct_declarator;
      struct_declarator;
      enum_specifier;
      list_enumerator;
      enumerator;
      declarator;
      direct_declarator;
      list_type_qualifier;
      parameter_type;
      parameter_declarations;
      parameter_declaration;
      list_ident;
      initializer_;
      initializers;
      type_name;
      abstract_declarator;
      dir_abs_dec;
      stm;
      labeled_stm;
      compound_stm;
      expression_stm;
      selection_stm;
      iter_stm;
      jump_stm;
      list_stm;
      constant;
      constant_expression;
      list_exp2;
      exp;
      exp2;
      exp3;
      exp4;
      exp5;
      exp6;
      exp7;
      exp8;
      exp9;
      exp10;
      exp11;
      exp12;
      exp13;
      exp14;
      exp15;
      exp16;
      exp17;
      unary_operator;
      assignment_op;

      progr';
      afunc';
      global';
      oldfunc';
      newfunc';
      oldfuncint';
      newfuncint';
      nodeclarator';
      declarators';
      type';
      storage';
      specprop';
      onlydecl';
      initdecl';
      tvoid';
      tchar';
      tshort';
      tint';
      tlong';
      tfloat';
      tdouble';
      tsigned';
      tunsigned';
      tstruct';
      tenum';
      tname';
      mytype';
      globalprograms';
      localprogram';
      localblock';
      localreg';
      const';
      nooptim';
      tag';
      unique';
      tagtype';
      struct';
      union';
      structen';
      typespec';
      qualspec';
      decl';
      field';
      decfield';
      enumdec';
      enumname';
      enumvar';
      plain';
      enuminit';
      beginpointer';
      nopointer';
      name';
      parendecl';
      innitarray';
      incomplete';
      newfuncdec';
      oldfuncdef';
      oldfuncdec';
      point';
      pointqual';
      pointpoint';
      pointqualpoint';
      allspec';
      more';
      paramdec';
      moreparamdec';
      onlytype';
      typeandparam';
      abstract';
      initexpr';
      initlistone';
      initlisttwo';
      aninit';
      moreinit';
      plaintype';
      extendedtype';
      pointerstart';
      advanced';
      pointadvanced';
      withinparentes';
      array';
      initiatedarray';
      uninitiated';
      initiated';
      oldfunction';
      newfunction';
      oldfuncexpr';
      newfuncexpr';
      labels';
      comps';
      exprs';
      sels';
      iters';
      jumps';
      slabelone';
      slabeltwo';
      slabelthree';
      scompone';
      scomptwo';
      scompthree';
      scompfour';
      sexprone';
      sexprtwo';
      sselone';
      sseltwo';
      sselthree';
      siterone';
      sitertwo';
      siterthree';
      siterfour';
      sjumpone';
      sjumptwo';
      sjumpthree';
      sjumpfour';
      sjumpfive';
      ecomma';
      eassign';
      econdition';
      elor';
      eland';
      ebitor';
      ebitexor';
      ebitand';
      eeq';
      eneq';
      elthen';
      egrthen';
      ele';
      ege';
      eleft';
      eright';
      eplus';
      eminus';
      etimes';
      ediv';
      emod';
      etypeconv';
      epreinc';
      epredec';
      epreop';
      ebytesexpr';
      ebytestype';
      earray';
      efunk';
      efunkpar';
      eselect';
      epoint';
      epostinc';
      epostdec';
      evar';
      econst';
      estring';
      echar';
      eunsigned';
      elong';
      eunsignlong';
      ehexadec';
      ehexaunsign';
      ehexalong';
      ehexaunslong';
      eoctal';
      eoctalunsign';
      eoctallong';
      eoctalunslong';
      edouble';
      efloat';
      elongdouble';
      eint';
      especial';
      address';
      indirection';
      plus';
      negative';
      complement';
      logicalneg';
      assign';
      assignmul';
      assigndiv';
      assignmod';
      assignadd';
      assignsub';
      assignleft';
      assignright';
      assignand';
      assignxor';
      assignor';

      u;
    ] = variables Vector.[
      "start";
      "ws";

      "ident";
      "string";
      "char";
      "integer";
      "unsigned";
      "long";
      "unsignedlong";
      "hexadecimal";
      "hexunsigned";
      "hexlong";
      "hexunslong";
      "octal";
      "octalunsigned";
      "octallong";
      "octalunslong";
      "double";
      "float";
      "longdouble";
      "type_void";
      "type_char";
      "type_short";
      "type_int";
      "type_long";
      "type_float";
      "type_double";
      "type_signed";
      "type_unsigned";
      "type_typedef";
      "typedef";
      "extern";
      "static";
      "auto";
      "register";
      "const";
      "volatile";
      "struct_";
      "union";
      "enum";
      "case";
      "default";
      "if_";
      "else_";
      "switch";
      "while_";
      "do_";
      "for_";
      "goto";
      "continue";
      "break";
      "return";
      "sizeof";
      "ternary_if";
      "ternary_else";
      "address";
      "indirection";
      "pointer";
      "bitcomp";
      "lneg";
      "semi";
      "lparen";
      "rparen";
      "comma";
      "lbrace";
      "rbrace";
      "colon";
      "lbrak";
      "rbrak";
      "assign";
      "plus_";
      "minus";
      "ellip";
      "bor";
      "band";
      "lor_";
      "land_";
      "bxor";
      "eq";
      "noteq";
      "lt";
      "gt";
      "gte";
      "lte";
      "lshift";
      "rshift";
      "times";
      "div";
      "rem";
      "plusplus";
      "minusminus";
      "dot";
      "arrow";
      "timesassign";
      "divassign";
      "remassign";
      "plusassign";
      "minusassign";
      "lshiftassign";
      "rshiftassign";
      "landassign";
      "lxorassign";
      "lorassign";

      "program";
      "list_external_declaration";
      "external_declaration";
      "function_def";
      "dec";
      "list_dec";
      "list_declaration_specifier";
      "declaration_specifier";
      "list_init_declarator";
      "init_declarator";
      "type_specifier";
      "storage_class_specifier";
      "type_qualifier";
      "struct_or_union_spec";
      "struct_or_union";
      "list_struct_dec";
      "struct_dec";
      "list_spec_qual";
      "spec_qual";
      "list_struct_declarator";
      "struct_declarator";
      "enum_specifier";
      "list_enumerator";
      "enumerator";
      "declarator";
      "direct_declarator";
      "list_type_qualifier";
      "parameter_type";
      "parameter_declarations";
      "parameter_declaration";
      "list_ident";
      "initializer_";
      "initializers";
      "type_name";
      "abstract_declarator";
      "dir_abs_dec";
      "stm";
      "labeled_stm";
      "compound_stm";
      "expression_stm";
      "selection_stm";
      "iter_stm";
      "jump_stm";
      "list_stm";
      "constant";
      "constant_expression";
      "list_exp2";
      "exp";
      "exp2";
      "exp3";
      "exp4";
      "exp5";
      "exp6";
      "exp7";
      "exp8";
      "exp9";
      "exp10";
      "exp11";
      "exp12";
      "exp13";
      "exp14";
      "exp15";
      "exp16";
      "exp17";
      "unary_operator";
      "assignment_op";

      "progr'";
      "afunc'";
      "global'";
      "oldfunc'";
      "newfunc'";
      "oldfuncint'";
      "newfuncint'";
      "nodeclarator'";
      "declarators'";
      "type'";
      "storage'";
      "specprop'";
      "onlydecl'";
      "initdecl'";
      "tvoid'";
      "tchar'";
      "tshort'";
      "tint'";
      "tlong'";
      "tfloat'";
      "tdouble'";
      "tsigned'";
      "tunsigned'";
      "tstruct'";
      "tenum'";
      "tname'";
      "mytype'";
      "globalprograms'";
      "localprogram'";
      "localblock'";
      "localreg'";
      "const'";
      "nooptim'";
      "tag'";
      "unique'";
      "tagtype'";
      "struct'";
      "union'";
      "structen'";
      "typespec'";
      "qualspec'";
      "decl'";
      "field'";
      "decfield'";
      "enumdec'";
      "enumname'";
      "enumvar'";
      "plain'";
      "enuminit'";
      "beginpointer'";
      "nopointer'";
      "name'";
      "parendecl'";
      "innitarray'";
      "incomplete'";
      "newfuncdec'";
      "oldfuncdef'";
      "oldfuncdec'";
      "point'";
      "pointqual'";
      "pointpoint'";
      "pointqualpoint'";
      "allspec'";
      "more'";
      "paramdec'";
      "moreparamdec'";
      "onlytype'";
      "typeandparam'";
      "abstract'";
      "initexpr'";
      "initlistone'";
      "initlisttwo'";
      "aninit'";
      "moreinit'";
      "plaintype'";
      "extendedtype'";
      "pointerstart'";
      "advanced'";
      "pointadvanced'";
      "withinparentes'";
      "array'";
      "initiatedarray'";
      "uninitiated'";
      "initiated'";
      "oldfunction'";
      "newfunction'";
      "oldfuncexpr'";
      "newfuncexpr'";
      "labels'";
      "comps'";
      "exprs'";
      "sels'";
      "iters'";
      "jumps'";
      "slabelone'";
      "slabeltwo'";
      "slabelthree'";
      "scompone'";
      "scomptwo'";
      "scompthree'";
      "scompfour'";
      "sexprone'";
      "sexprtwo'";
      "sselone'";
      "sseltwo'";
      "sselthree'";
      "siterone'";
      "sitertwo'";
      "siterthree'";
      "siterfour'";
      "sjumpone'";
      "sjumptwo'";
      "sjumpthree'";
      "sjumpfour'";
      "sjumpfive'";
      "ecomma'";
      "eassign'";
      "econdition'";
      "elor'";
      "eland'";
      "ebitor'";
      "ebitexor'";
      "ebitand'";
      "eeq'";
      "eneq'";
      "elthen'";
      "egrthen'";
      "ele'";
      "ege'";
      "eleft'";
      "eright'";
      "eplus'";
      "eminus'";
      "etimes'";
      "ediv'";
      "emod'";
      "etypeconv'";
      "epreinc'";
      "epredec'";
      "epreop'";
      "ebytesexpr'";
      "ebytestype'";
      "earray'";
      "efunk'";
      "efunkpar'";
      "eselect'";
      "epoint'";
      "epostinc'";
      "epostdec'";
      "evar'";
      "econst'";
      "estring'";
      "echar'";
      "eunsigned'";
      "elong'";
      "eunsignlong'";
      "ehexadec'";
      "ehexaunsign'";
      "ehexalong'";
      "ehexaunslong'";
      "eoctal'";
      "eoctalunsign'";
      "eoctallong'";
      "eoctalunslong'";
      "edouble'";
      "efloat'";
      "elongdouble'";
      "eint'";
      "especial'";
      "address'";
      "indirection'";
      "plus'";
      "negative'";
      "complement'";
      "logicalneg'";
      "assign'";
      "assignmul'";
      "assigndiv'";
      "assignmod'";
      "assignadd'";
      "assignsub'";
      "assignleft'";
      "assignright'";
      "assignand'";
      "assignxor'";
      "assignor'";

      "_";
    ]
  let syntactic = [
    start;
    program;
    list_external_declaration;
    external_declaration;
    function_def;
    dec;
    list_dec;
    list_declaration_specifier;
    declaration_specifier;
    list_init_declarator;
    init_declarator;
    type_specifier;
    storage_class_specifier;
    type_qualifier;
    struct_or_union_spec;
    struct_or_union;
    list_struct_dec;
    struct_dec;
    list_spec_qual;
    spec_qual;
    list_struct_declarator;
    struct_declarator;
    enum_specifier;
    list_enumerator;
    enumerator;
    declarator;
    direct_declarator;
    list_type_qualifier;
    parameter_type;
    parameter_declarations;
    parameter_declaration;
    list_ident;
    initializer_;
    initializers;
    type_name;
    abstract_declarator;
    dir_abs_dec;
    stm;
    labeled_stm;
    compound_stm;
    expression_stm;
    selection_stm;
    iter_stm;
    jump_stm;
    list_stm;
    constant;
    constant_expression;
    list_exp2;
    exp;
    exp2;
    exp3;
    exp4;
    exp5;
    exp6;
    exp7;
    exp8;
    exp9;
    exp10;
    exp11;
    exp12;
    exp13;
    exp14;
    exp15;
    exp16;
    exp17;
    unary_operator;
    assignment_op;
  ]
  let lexical = [
    ident;
    string;
    char;
    integer;
    unsigned;
    long;
    unsignedlong;
    hexadecimal;
    hexunsigned;
    hexlong;
    hexunslong;
    octal;
    octalunsigned;
    octallong;
    octalunslong;
    double;
    float;
    longdouble;
    type_void;
    type_char;
    type_short;
    type_int;
    type_long;
    type_float;
    type_double;
    type_signed;
    type_unsigned;
    type_typedef;
    typedef;
    extern;
    static;
    auto;
    register;
    const;
    volatile;
    struct_;
    union;
    enum;
    case;
    default;
    if_;
    else_;
    switch;
    while_;
    do_;
    for_;
    goto;
    continue;
    break;
    return;
    sizeof;
    ternary_if;
    ternary_else;
    address;
    indirection;
    pointer;
    bitcomp;
    lneg;
    semi;
    lparen;
    rparen;
    comma;
    lbrace;
    rbrace;
    colon;
    lbrak;
    rbrak;
    assign;
    plus_;
    minus;
    ellip;
    bor;
    band;
    lor_;
    land_;
    bxor;
    eq;
    noteq;
    lt;
    gt;
    gte;
    lte;
    lshift;
    rshift;
    times;
    div;
    rem;
    plusplus;
    minusminus;
    dot;
    arrow;
    timesassign;
    divassign;
    remassign;
    plusassign;
    minusassign;
    lshiftassign;
    rshiftassign;
    landassign;
    lxorassign;
    lorassign;
    ws;
  ]

  let longest_match = [
    ident;
    ws;
    type_typedef;
  ]

  let start = start

  let parser =
    with_ws (T.Vars.of_list lexical) (var ws) Production.[
      make (u, start) R.(var program * plus eof);

      make (progr', program) (var list_external_declaration);

      make (u, list_external_declaration) (var external_declaration);
      make (u, list_external_declaration) R.(var external_declaration * var list_external_declaration);

      make (afunc', external_declaration) (var function_def);
      make (global', external_declaration) (var dec);

      make (oldfunc', function_def) R.(var list_declaration_specifier * var declarator * var list_dec * var compound_stm);
      make (newfunc', function_def) R.(var list_declaration_specifier * var declarator * var compound_stm);
      make (oldfuncint', function_def) R.(var declarator * var list_dec * var compound_stm);
      make (newfuncint', function_def) R.(var declarator * var compound_stm);

      make (nodeclarator', dec) R.(var list_declaration_specifier * var semi);
      make (declarators', dec) R.(var list_declaration_specifier * var list_init_declarator * var semi);

      make (u, list_dec) (var dec);
      make (u, list_dec) R.(var dec * var list_dec);

      make (u, list_declaration_specifier) (var declaration_specifier);
      make (u, list_declaration_specifier) R.(var declaration_specifier * var list_declaration_specifier);

      make (type', declaration_specifier) (var type_specifier);
      make (storage', declaration_specifier) (var storage_class_specifier);
      make (specprop', declaration_specifier) (var type_qualifier);

      make (u, list_init_declarator) (var init_declarator);
      make (u, list_init_declarator) R.(var init_declarator * var comma * var list_init_declarator);

      make (onlydecl', init_declarator) (var declarator);
      make (initdecl', init_declarator) R.(var declarator * var assign * var initializer_);

      make (tvoid', type_specifier) (var type_void);
      make (tchar', type_specifier) (var type_char);
      make (tshort', type_specifier) (var type_short);
      make (tint', type_specifier) (var type_int);
      make (tlong', type_specifier) (var type_long);
      make (tfloat', type_specifier) (var type_float);
      make (tdouble', type_specifier) (var type_double);
      make (tsigned', type_specifier) (var type_signed);
      make (tunsigned', type_specifier) (var type_unsigned);
      make (tstruct', type_specifier) (var struct_or_union_spec);
      make (tenum', type_specifier) (var enum_specifier);
      make (tname', type_specifier) (var type_typedef);

      make (mytype', storage_class_specifier) (var typedef);
      make (globalprograms', storage_class_specifier) (var extern);
      make (localprogram', storage_class_specifier) (var static);
      make (localblock', storage_class_specifier) (var auto);
      make (localreg', storage_class_specifier) (var register);

      make (const', type_qualifier) (var const);
      make (nooptim', type_qualifier) (var volatile);

      make (tag', struct_or_union_spec) R.(var struct_or_union * var ident * var lbrace * var list_struct_dec * var rbrace);
      make (unique', struct_or_union_spec) R.(var struct_or_union * var lbrace * var list_struct_dec * var rbrace);
      make (tagtype', struct_or_union_spec) R.(var struct_or_union * var ident);

      make (struct', struct_or_union) (var struct_);
      make (union', struct_or_union) (var union);

      make (u, list_struct_dec) (var struct_dec);
      make (u, list_struct_dec) R.(var struct_dec * var list_struct_dec);

      make (structen', struct_dec) R.(var list_spec_qual * var list_struct_declarator * var semi);

      make (u, list_spec_qual) (var spec_qual);
      make (u, list_spec_qual) R.(var spec_qual * var list_spec_qual);

      make (typespec', spec_qual) (var type_specifier);
      make (qualspec', spec_qual) (var type_qualifier);

      make (u, list_struct_declarator) (var struct_declarator);
      make (u, list_struct_declarator) R.(var struct_declarator * var comma * var list_struct_declarator);

      make (decl', struct_declarator) (var declarator);
      make (field', struct_declarator) R.(var colon * var constant_expression);
      make (decfield', struct_declarator) R.(var declarator * var colon * var constant_expression);


      make (enumdec', enum_specifier) R.(var enum * var lbrace * var list_enumerator * var rbrace);
      make (enumname', enum_specifier) R.(var enum * var ident * var lbrace * var list_enumerator * var rbrace);
      make (enumvar', enum_specifier) R.(var enum * var ident);

      make (u, list_enumerator) (var enumerator);
      make (u, list_enumerator) R.(var enumerator * var comma);
      make (u, list_enumerator) R.(var enumerator * var comma * var list_enumerator);

      make (plain', enumerator) (var ident);
      make (enuminit', enumerator) R.(var ident * var assign * var constant_expression);


      make (beginpointer', declarator) R.(var pointer * var direct_declarator);
      make (nopointer', declarator) (var direct_declarator);

      make (name', direct_declarator) (var ident);
      make (parendecl', direct_declarator) R.(var lparen * var declarator * var rparen);
      make (innitarray', direct_declarator) R.(var direct_declarator * var lbrak * var constant_expression * var rbrak);
      make (incomplete', direct_declarator) R.(var direct_declarator * var lbrak * var rbrak);
      make (newfuncdec', direct_declarator) R.(var direct_declarator * var lparen * var parameter_type * var rparen);
      make (oldfuncdef', direct_declarator) R.(var direct_declarator * var lparen * var list_ident * var rparen);
      make (oldfuncdec', direct_declarator) R.(var direct_declarator * var lparen * var rparen);

      make (point', pointer) (var pointer);
      make (pointqual', pointer) R.(var pointer * var list_type_qualifier);
      make (pointpoint', pointer) R.(var pointer * var pointer);
      make (pointqualpoint', pointer) R.(var pointer * var list_type_qualifier * var pointer);

      make (u, list_type_qualifier) (var type_qualifier);
      make (u, list_type_qualifier) R.(var type_qualifier * var list_type_qualifier);

      make (allspec', parameter_type) (var parameter_declarations);
      make (more', parameter_type) R.(var parameter_declarations * var comma * var ellip);

      make (paramdec', parameter_declarations) (var parameter_declaration);
      make (moreparamdec', parameter_declarations) R.(var parameter_declarations * var comma * var parameter_declaration);

      make (onlytype', parameter_declaration) (var list_declaration_specifier);
      make (typeandparam', parameter_declaration) R.(var list_declaration_specifier * var declarator);
      make (abstract', parameter_declaration) R.(var list_declaration_specifier * var abstract_declarator);

      make (u, list_ident) (var ident);
      make (u, list_ident) R.(var ident * var comma * var list_ident);

      make (initexpr', initializer_) (var exp2);
      make (initlistone', initializer_) R.(var lbrace * var initializers * var rbrace);
      make (initlisttwo', initializer_) R.(var lbrace * var initializers * var comma * var rbrace);

      make (aninit', initializers) (var initializer_);
      make (moreinit', initializers) R.(var initializers * var comma * var initializer_);

      make (plaintype', type_name) (var list_spec_qual);
      make (extendedtype', type_name) R.(var list_spec_qual * var abstract_declarator);

      make (pointerstart', abstract_declarator) (var pointer);
      make (advanced', abstract_declarator) (var dir_abs_dec);
      make (pointadvanced', abstract_declarator) R.(var pointer * var dir_abs_dec);

      make (withinparentes', dir_abs_dec) R.(var lparen * var abstract_declarator * var rparen);
      make (array', dir_abs_dec) R.(var lbrak * var rbrak);
      make (initiatedarray', dir_abs_dec) R.(var lbrak * var constant_expression * var rbrak);
      make (uninitiated', dir_abs_dec) R.(var dir_abs_dec * var lbrak * var rbrak);
      make (initiated', dir_abs_dec) R.(var dir_abs_dec * var lbrak * var constant_expression * var rbrak);
      make (oldfunction', dir_abs_dec) R.(var lparen * var rparen);
      make (newfunction', dir_abs_dec) R.(var lparen * var parameter_type * var rparen);
      make (oldfuncexpr', dir_abs_dec) R.(var dir_abs_dec * var lparen * var rparen);
      make (newfuncexpr', dir_abs_dec) R.(var dir_abs_dec * var lparen * var parameter_type * var rparen);

      make (labels', stm) (var labeled_stm);
      make (comps', stm) (var compound_stm);
      make (exprs', stm) (var expression_stm);
      make (sels', stm) (var selection_stm);
      make (iters', stm) (var iter_stm);
      make (jumps', stm) (var jump_stm);

      make (slabelone', labeled_stm) R.(var ident * var colon * var stm);
      make (slabeltwo', labeled_stm) R.(var case * var constant_expression * var colon * var stm);
      make (slabelthree', labeled_stm) R.(var default * var colon * var stm);

      make (scompone', compound_stm) R.(var lbrace * var rbrace);
      make (scomptwo', compound_stm) R.(var lbrace * var list_stm * var rbrace);
      make (scompthree', compound_stm) R.(var lbrace * var list_dec * var rbrace);
      make (scompfour', compound_stm) R.(var lbrace * var list_dec * var list_stm * var rbrace);

      make (sexprone', expression_stm) (var semi);
      make (sexprtwo', expression_stm) R.(var exp * var semi);

      make (sselone', selection_stm) R.(var if_ * var lparen * var exp * var rparen * var stm);
      make (sseltwo', selection_stm) R.(var if_ * var lparen * var exp * var rparen * var stm * var else_ * var stm);
      make (sselthree', selection_stm) R.(var switch * var lparen * var exp * var rparen * var stm);

      make (siterone', iter_stm) R.(var while_ * var lparen * var exp * var rparen * var stm);
      make (sitertwo', iter_stm) R.(var do_ * var stm * var while_ * var lparen * var exp * var rparen * var semi);
      make (siterthree', iter_stm) R.(var for_ * var lparen * var expression_stm * var expression_stm * var rparen * var stm);
      make (siterfour', iter_stm) R.(var for_ * var lparen * var expression_stm * var expression_stm * var exp * var rparen * var stm);

      make (sjumpone', jump_stm) R.(var goto * var ident * var semi);
      make (sjumptwo', jump_stm) R.(var continue * var semi);
      make (sjumpthree', jump_stm) R.(var break * var semi);
      make (sjumpfour', jump_stm) R.(var return * var semi);
      make (sjumpfive', jump_stm) R.(var return * var exp * var semi);

      make (u, list_stm) (var stm);
      make (u, list_stm) R.(var stm * var list_stm);

      make (ecomma', exp) R.(var exp * var comma * var exp2);
      make (eassign', exp2) R.(var exp15 * var assignment_op * var exp2);
      make (econdition', exp3) R.(var exp4 * var ternary_if * var exp * var ternary_else * var exp3);
      make (elor', exp4) R.(var exp4 * var lor_ * var exp5);
      make (eland', exp5) R.(var exp5 * var land_ * var exp6);
      make (ebitor', exp6) R.(var exp6 * var bor * var exp7);
      make (ebitexor', exp7) R.(var exp7 * var bxor * var exp8);
      make (ebitand', exp8) R.(var exp8 * var band * var exp9);
      make (eeq', exp9) R.(var exp9 * var eq * var exp10);
      make (eneq', exp9) R.(var exp9 * var noteq * var exp10);
      make (elthen', exp10) R.(var exp10 * var lt * var exp11);
      make (egrthen', exp10) R.(var exp10 * var gt * var exp11);
      make (ele', exp10) R.(var exp10 * var lte * var exp11);
      make (ege', exp10) R.(var exp10 * var gte * var exp11);
      make (eleft', exp11) R.(var exp11 * var lshift * var exp12);
      make (eright', exp11) R.(var exp11 * var rshift * var exp12);
      make (eplus', exp12) R.(var exp12 * var plus_ * var exp13);
      make (eminus', exp12) R.(var exp12 * var minus * var exp13);
      make (etimes', exp13) R.(var exp13 * var times * var exp14);
      make (ediv', exp13) R.(var exp13 * var div * var exp14);
      make (emod', exp13) R.(var exp13 * var rem * var exp14);
      make (etypeconv', exp14) R.(var lparen * var type_name * var rparen * var exp14);
      make (epreinc', exp15) R.(var plusplus * var exp15);
      make (epredec', exp15) R.(var minusminus * var exp15);
      make (epreop', exp15) R.(var unary_operator * var exp14);
      make (ebytesexpr', exp15) R.(var sizeof * var exp15);
      make (ebytestype', exp15) R.(var sizeof * var lparen * var type_name * var rparen);
      make (earray', exp16) R.(var exp16 * var lbrak * var exp * var rbrak);
      make (efunk', exp16) R.(var exp16 * var lparen * var rparen);
      make (efunkpar', exp16) R.(var exp16 * var lparen * var list_exp2 * var rparen);
      make (eselect', exp16) R.(var exp16 * var dot * var ident);
      make (epoint', exp16) R.(var exp16 * var arrow * var ident);
      make (epostinc', exp16) R.(var exp16 * var plusplus);
      make (epostdec', exp16) R.(var exp16 * var minusminus);
      make (evar', exp17) (var ident);
      make (econst', exp17) (var constant);
      make (estring', exp17) (var string);

      make (echar', constant) (var char);
      make (eunsigned', constant) (var unsigned);
      make (elong', constant) (var long);
      make (eunsignlong', constant) (var unsignedlong);
      make (ehexadec', constant) (var hexadecimal);
      make (ehexaunsign', constant) (var hexunsigned);
      make (ehexalong', constant) (var hexlong);
      make (ehexaunslong', constant) (var hexunslong);
      make (eoctal', constant) (var octal);
      make (eoctalunsign', constant) (var octalunsigned);
      make (eoctallong', constant) (var octallong);
      make (eoctalunslong', constant) (var octalunslong);
      make (edouble', constant) (var double);
      make (efloat', constant) (var float);
      make (elongdouble', constant) (var longdouble);
      make (eint', constant) (var integer);

      make (especial', constant_expression) (var exp3);

      make (u, list_exp2) (var exp2);
      make (u, list_exp2) R.(var exp2 * var comma * var list_exp2);

      make (u, exp) (var exp2);
      make (u, exp2) (var exp3);
      make (u, exp3) (var exp4);
      make (u, exp4) (var exp5);
      make (u, exp5) (var exp6);
      make (u, exp6) (var exp7);
      make (u, exp7) (var exp8);
      make (u, exp8) (var exp9);
      make (u, exp9) (var exp10);
      make (u, exp10) (var exp11);
      make (u, exp11) (var exp12);
      make (u, exp12) (var exp13);
      make (u, exp13) (var exp14);
      make (u, exp14) (var exp15);
      make (u, exp15) (var exp16);
      make (u, exp16) (var exp17);
      make (u, exp17) R.(var lparen * var exp * var rparen);

      make (address', unary_operator) (var address);
      make (indirection', unary_operator) (var indirection);
      make (plus', unary_operator) (var plus_);
      make (negative', unary_operator) (var minus);
      make (complement', unary_operator) (var bitcomp);
      make (logicalneg', unary_operator) (var lneg);

      make (assign', assignment_op) (var assign);
      make (assignmul', assignment_op) (var timesassign);
      make (assigndiv', assignment_op) (var divassign);
      make (assignmod', assignment_op) (var remassign);
      make (assignadd', assignment_op) (var plusassign);
      make (assignsub', assignment_op) (var minusassign);
      make (assignleft', assignment_op) (var lshiftassign);
      make (assignright', assignment_op) (var rshiftassign);
      make (assignand', assignment_op) (var landassign);
      make (assignxor', assignment_op) (var lxorassign);
      make (assignor', assignment_op) (var lorassign);
    ]

  let scanner =
    let letter = R.(range "A" "Z" + range "a" "z" + codes "_") in
    let digit = range "0" "9" in
    let ident_ = R.(letter * star (letter + digit)) in
    let nzdigit = range "1" "9" in
    let hexdigit = R.(range "a" "f" + range "A" "F") in
    let octdigit = range "0" "7" in
    let integer_ = R.(nzdigit * star digit) in
    let hexdecimal_ = R.(codes "0" * codes "xX" * plus (digit + hexdigit)) in
    let octal_ = R.(codes "0" * star octdigit) in
    let double_ = R.(((star digit * codes "." * plus digit) + (plus digit * codes ".")) * (opt (codes "eE" * opt (codes "+-") * plus digit)) + plus digit * codes "eE" * opt (codes "+-") * plus digit) in
    Production.[
      make (u, ident) ident_;
      make (u, string) R.(codes "\"" * (not_codes "\"\\" + codes "\\" * any) * codes "\"");
      make (u, char) R.(codes "'" * (not_codes "'\\" + codes "\\" * any) * codes "'");
      make (u, integer) integer_;
      make (u, unsigned) R.(integer_ * codes "uU");
      make (u, long) R.(integer_ * codes "lL");
      make (u, unsignedlong) R.(integer_ * (text "ul" * text "UL"));
      make (u, hexadecimal) hexdecimal_;
      make (u, hexunsigned) R.(hexdecimal_ * codes "uU");
      make (u, hexlong) R.(hexdecimal_ * codes "lL");
      make (u, hexunslong) R.(hexdecimal_ * (text "ul" * text "UL"));
      make (u, octal) octal_;
      make (u, octalunsigned) R.(octal_ * codes "uU");
      make (u, octallong) R.(octal_ * codes "lL");
      make (u, octalunslong) R.(octal_ * (text "ul" * text "UL"));
      make (u, double) double_;
      make (u, float) R.(double_ * codes "fF");
      make (u, longdouble) R.(double_ * codes "lL");

      make (u, type_void) (text "void");
      make (u, type_char) (text "char");
      make (u, type_short) (text "short");
      make (u, type_int) (text "int");
      make (u, type_long) (text "long");
      make (u, type_float) (text "float");
      make (u, type_double) (text "double");
      make (u, type_signed) (text "signed");
      make (u, type_unsigned) (text "unsigned");
      make (u, type_typedef) ident_;

      make (u, typedef) (text "typedef");
      make (u, extern) (text "extern");
      make (u, static) (text "static");
      make (u, auto) (text "auto");
      make (u, register) (text "register");
      make (u, const) (text "const");
      make (u, volatile) (text "volatile");
      make (u, struct_) (text "struct");
      make (u, union) (text "union");
      make (u, enum) (text "enum");
      make (u, case) (text "case");
      make (u, default) (text "default");
      make (u, if_) (text "if");
      make (u, else_) (text "else");
      make (u, switch) (text "switch");
      make (u, while_) (text "while");
      make (u, do_) (text "do");
      make (u, for_) (text "for");
      make (u, goto) (text "goto");
      make (u, continue) (text "continue");
      make (u, break) (text "break");
      make (u, return) (text "return");
      make (u, sizeof) (text "sizeof");

      make (u, ternary_if) (codes "?");
      make (u, ternary_else) (codes ":");
      make (u, address) (codes "&");
      make (u, indirection) (codes "*");
      make (u, pointer) (codes "*");
      make (u, bitcomp) (codes "~");
      make (u, lneg) (codes "!");

      make (u, semi) (text ";");
      make (u, lparen) (text "(");
      make (u, rparen) (text ")");
      make (u, comma) (text ",");
      make (u, lbrace) (text "{");
      make (u, rbrace) (text "}");
      make (u, colon) (text ":");
      make (u, lbrak) (text "[");
      make (u, rbrak) (text "]");
      make (u, assign) (text "=");
      make (u, plus_) (text "+");
      make (u, minus) (text "-");
      make (u, ellip) (text "...");
      make (u, bor) (text "|");
      make (u, band) (text "&");
      make (u, lor_) (text "||");
      make (u, land_) (text "&&");
      make (u, bxor) (text "^");
      make (u, eq) (text "==");
      make (u, noteq) (text "!=");
      make (u, lt) (text "<");
      make (u, gt) (text ">");
      make (u, gte) (text ">=");
      make (u, lte) (text "<=");
      make (u, lshift) (text "<<");
      make (u, rshift) (text ">>");
      make (u, times) (text "*");
      make (u, div) (text "/");
      make (u, rem) (text "%");
      make (u, plusplus) (text "++");
      make (u, minusminus) (text "--");
      make (u, dot) (text ".");
      make (u, arrow) (text "->");
      make (u, timesassign) (text "*=");
      make (u, divassign) (text "/=");
      make (u, remassign) (text "%=");
      make (u, plusassign) (text "+=");
      make (u, minusassign) (text "-=");
      make (u, lshiftassign) (text "<<=");
      make (u, rshiftassign) (text ">>=");
      make (u, landassign) (text "&=");
      make (u, lxorassign) (text "^=");
      make (u, lorassign) (text "|=");

      make (u, ws) R.(star (codes " \n\r\t"));
    ]

end)

let _ =
  let d = X.driver () in
  X.Run.file (fun c -> d#read c) "test.c";
  Fmt.pr "@[%s@]" (Dot.string_of_graph d#to_dot);
  Fmt.pr "@[%s@]" (Dot.string_of_graph (T.Node_packed_forest.to_dot d#forest))
