open Te_bot
open Te_core
module T = Types

module X = Spec.Build(functor(Context: Spec.CONTEXT) -> struct
  open Context

  let Vector.[
      start;
      ws;

      ident;
      string;
      char;
      integer;
      unsigned;
      long;
      unsignedlong;
      hexadecimal;
      hexunsigned;
      hexlong;
      hexunslong;
      octal;
      octalunsigned;
      octallong;
      octalunslong;
      double;
      float;
      longdouble;
      type_void;
      type_char;
      type_short;
      type_int;
      type_long;
      type_float;
      type_double;
      type_signed;
      type_unsigned;
      type_typedef;
      typedef;
      extern;
      static;
      auto;
      register;
      const;
      volatile;
      struct_;
      union;
      enum;
      case;
      default;
      if_;
      else_;
      switch;
      while_;
      do_;
      for_;
      goto;
      continue;
      break;
      return;
      sizeof;
      ternary_if;
      ternary_else;
      address;
      indirection;
      pointer;
      bitcomp;
      lneg;

      program;
      list_external_declaration;
      external_declaration;
      function_def;
      dec;
      list_dec;
      list_declaration_specifier;
      declaration_specifier;
      list_init_declarator;
      init_declarator;
      type_specifier;
      storage_class_specifier;
      type_qualifier;
      struct_or_union_spec;
      struct_or_union;
      list_struct_dec;
      struct_dec;
      list_spec_qual;
      spec_qual;
      list_struct_declarator;
      struct_declarator;
      enum_specifier;
      list_enumerator;
      enumerator;
      declarator;
      direct_declarator;
      list_type_qualifier;
      parameter_type;
      parameter_declarations;
      parameter_declaration;
      list_ident;
      initializer_;
      initializers;
      type_name;
      abstract_declarator;
      dir_abs_dec;
      stm;
      labeled_stm;
      compound_stm;
      expression_stm;
      selection_stm;
      iter_stm;
      jump_stm;
      list_stm;
      constant;
      constant_expression;
      list_exp2;
      exp;
      exp2;
      exp3;
      exp4;
      exp5;
      exp6;
      exp7;
      exp8;
      exp9;
      exp10;
      exp11;
      exp12;
      exp13;
      exp14;
      exp15;
      exp16;
      exp17;
      unary_operator;
      assignment_op;

      progr';
      afunc';
      global';
      oldfunc';
      newfunc';
      oldfuncint';
      newfuncint';
      nodeclarator';
      declarators';
      type';
      storage';
      specprop';
      onlydecl';
      initdecl';
      tvoid';
      tchar';
      tshort';
      tint';
      tlong';
      tfloat';
      tdouble';
      tsigned';
      tunsigned';
      tstruct';
      tenum';
      tname';
      mytype';
      globalprograms';
      localprogram';
      localblock';
      localreg';
      const';
      nooptim';
      tag';
      unique';
      tagtype';
      struct';
      union';
      structen';
      typespec';
      qualspec';
      decl';
      field';
      decfield';
      enumdec';
      enumname';
      enumvar';
      plain';
      enuminit';
      beginpointer';
      nopointer';
      name';
      parendecl';
      innitarray';
      incomplete';
      newfuncdec';
      oldfuncdef';
      oldfuncdec';
      point';
      pointqual';
      pointpoint';
      pointqualpoint';
      allspec';
      more';
      paramdec';
      moreparamdec';
      onlytype';
      typeandparam';
      abstract';
      initexpr';
      initlistone';
      initlisttwo';
      aninit';
      moreinit';
      plaintype';
      extendedtype';
      pointerstart';
      advanced';
      pointadvanced';
      withinparentes';
      array';
      initiatedarray';
      uninitiated';
      initiated';
      oldfunction';
      newfunction';
      oldfuncexpr';
      newfuncexpr';
      labels';
      comps';
      exprs';
      sels';
      iters';
      jumps';
      slabelone';
      slabeltwo';
      slabelthree';
      scompone';
      scomptwo';
      scompthree';
      scompfour';
      sexprone';
      sexprtwo';
      sselone';
      sseltwo';
      sselthree';
      siterone';
      sitertwo';
      siterthree';
      siterfour';
      sjumpone';
      sjumptwo';
      sjumpthree';
      sjumpfour';
      sjumpfive';
      ecomma';
      eassign';
      econdition';
      elor';
      eland';
      ebitor';
      ebitexor';
      ebitand';
      eeq';
      eneq';
      elthen';
      egrthen';
      ele';
      ege';
      eleft';
      eright';
      eplus';
      eminus';
      etimes';
      ediv';
      emod';
      etypeconv';
      epreinc';
      epredec';
      epreop';
      ebytesexpr';
      ebytestype';
      earray';
      efunk';
      efunkpar';
      eselect';
      epoint';
      epostinc';
      epostdec';
      evar';
      econst';
      estring';
      echar';
      eunsigned';
      elong';
      eunsignlong';
      ehexadec';
      ehexaunsign';
      ehexalong';
      ehexaunslong';
      eoctal';
      eoctalunsign';
      eoctallong';
      eoctalunslong';
      edouble';
      efloat';
      elongdouble';
      eint';
      especial';
      address';
      indirection';
      plus';
      negative';
      complement';
      logicalneg';
      assign';
      assignmul';
      assigndiv';
      assignmod';
      assignadd';
      assignsub';
      assignleft';
      assignright';
      assignand';
      assignxor';
      assignor';

      u;
    ] = variables Vector.[
      "start";
      "ws";

      "ident";
      "string";
      "char";
      "integer";
      "unsigned";
      "long";
      "unsignedlong";
      "hexadecimal";
      "hexunsigned";
      "hexlong";
      "hexunslong";
      "octal";
      "octalunsigned";
      "octallong";
      "octalunslong";
      "double";
      "float";
      "longdouble";
      "type_void";
      "type_char";
      "type_short";
      "type_int";
      "type_long";
      "type_float";
      "type_double";
      "type_signed";
      "type_unsigned";
      "type_typedef";
      "typedef";
      "extern";
      "static";
      "auto";
      "register";
      "const";
      "volatile";
      "struct_";
      "union";
      "enum";
      "case";
      "default";
      "if_";
      "else_";
      "switch";
      "while_";
      "do_";
      "for_";
      "goto";
      "continue";
      "break";
      "return";
      "sizeof";
      "ternary_if";
      "ternary_else";
      "address";
      "indirection";
      "pointer";
      "bitcomp";
      "lneg";

      "program";
      "list_external_declaration";
      "external_declaration";
      "function_def";
      "dec";
      "list_dec";
      "list_declaration_specifier";
      "declaration_specifier";
      "list_init_declarator";
      "init_declarator";
      "type_specifier";
      "storage_class_specifier";
      "type_qualifier";
      "struct_or_union_spec";
      "struct_or_union";
      "list_struct_dec";
      "struct_dec";
      "list_spec_qual";
      "spec_qual";
      "list_struct_declarator";
      "struct_declarator";
      "enum_specifier";
      "list_enumerator";
      "enumerator";
      "declarator";
      "direct_declarator";
      "list_type_qualifier";
      "parameter_type";
      "parameter_declarations";
      "parameter_declaration";
      "list_ident";
      "initializer_";
      "initializers";
      "type_name";
      "abstract_declarator";
      "dir_abs_dec";
      "stm";
      "labeled_stm";
      "compound_stm";
      "expression_stm";
      "selection_stm";
      "iter_stm";
      "jump_stm";
      "list_stm";
      "constant";
      "constant_expression";
      "list_exp2";
      "exp";
      "exp2";
      "exp3";
      "exp4";
      "exp5";
      "exp6";
      "exp7";
      "exp8";
      "exp9";
      "exp10";
      "exp11";
      "exp12";
      "exp13";
      "exp14";
      "exp15";
      "exp16";
      "exp17";
      "unary_operator";
      "assignment_op";

      "progr'";
      "afunc'";
      "global'";
      "oldfunc'";
      "newfunc'";
      "oldfuncint'";
      "newfuncint'";
      "nodeclarator'";
      "declarators'";
      "type'";
      "storage'";
      "specprop'";
      "onlydecl'";
      "initdecl'";
      "tvoid'";
      "tchar'";
      "tshort'";
      "tint'";
      "tlong'";
      "tfloat'";
      "tdouble'";
      "tsigned'";
      "tunsigned'";
      "tstruct'";
      "tenum'";
      "tname'";
      "mytype'";
      "globalprograms'";
      "localprogram'";
      "localblock'";
      "localreg'";
      "const'";
      "nooptim'";
      "tag'";
      "unique'";
      "tagtype'";
      "struct'";
      "union'";
      "structen'";
      "typespec'";
      "qualspec'";
      "decl'";
      "field'";
      "decfield'";
      "enumdec'";
      "enumname'";
      "enumvar'";
      "plain'";
      "enuminit'";
      "beginpointer'";
      "nopointer'";
      "name'";
      "parendecl'";
      "innitarray'";
      "incomplete'";
      "newfuncdec'";
      "oldfuncdef'";
      "oldfuncdec'";
      "point'";
      "pointqual'";
      "pointpoint'";
      "pointqualpoint'";
      "allspec'";
      "more'";
      "paramdec'";
      "moreparamdec'";
      "onlytype'";
      "typeandparam'";
      "abstract'";
      "initexpr'";
      "initlistone'";
      "initlisttwo'";
      "aninit'";
      "moreinit'";
      "plaintype'";
      "extendedtype'";
      "pointerstart'";
      "advanced'";
      "pointadvanced'";
      "withinparentes'";
      "array'";
      "initiatedarray'";
      "uninitiated'";
      "initiated'";
      "oldfunction'";
      "newfunction'";
      "oldfuncexpr'";
      "newfuncexpr'";
      "labels'";
      "comps'";
      "exprs'";
      "sels'";
      "iters'";
      "jumps'";
      "slabelone'";
      "slabeltwo'";
      "slabelthree'";
      "scompone'";
      "scomptwo'";
      "scompthree'";
      "scompfour'";
      "sexprone'";
      "sexprtwo'";
      "sselone'";
      "sseltwo'";
      "sselthree'";
      "siterone'";
      "sitertwo'";
      "siterthree'";
      "siterfour'";
      "sjumpone'";
      "sjumptwo'";
      "sjumpthree'";
      "sjumpfour'";
      "sjumpfive'";
      "ecomma'";
      "eassign'";
      "econdition'";
      "elor'";
      "eland'";
      "ebitor'";
      "ebitexor'";
      "ebitand'";
      "eeq'";
      "eneq'";
      "elthen'";
      "egrthen'";
      "ele'";
      "ege'";
      "eleft'";
      "eright'";
      "eplus'";
      "eminus'";
      "etimes'";
      "ediv'";
      "emod'";
      "etypeconv'";
      "epreinc'";
      "epredec'";
      "epreop'";
      "ebytesexpr'";
      "ebytestype'";
      "earray'";
      "efunk'";
      "efunkpar'";
      "eselect'";
      "epoint'";
      "epostinc'";
      "epostdec'";
      "evar'";
      "econst'";
      "estring'";
      "echar'";
      "eunsigned'";
      "elong'";
      "eunsignlong'";
      "ehexadec'";
      "ehexaunsign'";
      "ehexalong'";
      "ehexaunslong'";
      "eoctal'";
      "eoctalunsign'";
      "eoctallong'";
      "eoctalunslong'";
      "edouble'";
      "efloat'";
      "elongdouble'";
      "eint'";
      "especial'";
      "address'";
      "indirection'";
      "plus'";
      "negative'";
      "complement'";
      "logicalneg'";
      "assign'";
      "assignmul'";
      "assigndiv'";
      "assignmod'";
      "assignadd'";
      "assignsub'";
      "assignleft'";
      "assignright'";
      "assignand'";
      "assignxor'";
      "assignor'";

      "_";
    ]
  let syntactic = [
    start;
    program;
    list_external_declaration;
    external_declaration;
    function_def;
    dec;
    list_dec;
    list_declaration_specifier;
    declaration_specifier;
    list_init_declarator;
    init_declarator;
    type_specifier;
    storage_class_specifier;
    type_qualifier;
    struct_or_union_spec;
    struct_or_union;
    list_struct_dec;
    struct_dec;
    list_spec_qual;
    spec_qual;
    list_struct_declarator;
    struct_declarator;
    enum_specifier;
    list_enumerator;
    enumerator;
    declarator;
    direct_declarator;
    list_type_qualifier;
    parameter_type;
    parameter_declarations;
    parameter_declaration;
    list_ident;
    initializer_;
    initializers;
    type_name;
    abstract_declarator;
    dir_abs_dec;
    stm;
    labeled_stm;
    compound_stm;
    expression_stm;
    selection_stm;
    iter_stm;
    jump_stm;
    list_stm;
    constant;
    constant_expression;
    list_exp2;
    exp;
    exp2;
    exp3;
    exp4;
    exp5;
    exp6;
    exp7;
    exp8;
    exp9;
    exp10;
    exp11;
    exp12;
    exp13;
    exp14;
    exp15;
    exp16;
    exp17;
    unary_operator;
    assignment_op;
  ]
  let lexical = [
    ident;
    string;
    char;
    integer;
    unsigned;
    long;
    unsignedlong;
    hexadecimal;
    hexunsigned;
    hexlong;
    hexunslong;
    octal;
    octalunsigned;
    octallong;
    octalunslong;
    double;
    float;
    longdouble;
    type_void;
    type_char;
    type_short;
    type_int;
    type_long;
    type_float;
    type_double;
    type_signed;
    type_unsigned;
    type_typedef;
    typedef;
    extern;
    static;
    auto;
    register;
    const;
    volatile;
    struct_;
    union;
    enum;
    case;
    default;
    if_;
    else_;
    switch;
    while_;
    do_;
    for_;
    goto;
    continue;
    break;
    return;
    sizeof;
    ternary_if;
    ternary_else;
    address;
    indirection;
    pointer;
    bitcomp;
    lneg;
    ws;
  ]

  let longest_match = [
    ident;
    ws;
    type_typedef;
  ]

  let start = start

  let parser =
    with_ws (T.Vars.of_list lexical) (var ws) Production.[
      make (u, start) R.(var program * plus eof);

      make (progr', program) (var list_external_declaration);

      make (u, list_external_declaration) (var external_declaration);
      make (u, list_external_declaration) R.(var external_declaration * var list_external_declaration);

      make (afunc', external_declaration) (var function_def);
      make (global', external_declaration) (var dec);

      make (oldfunc', function_def) R.(var list_declaration_specifier * var declarator * var list_dec * var compound_stm);
      make (newfunc', function_def) R.(var list_declaration_specifier * var declarator * var compound_stm);
      make (oldfuncint', function_def) R.(var declarator * var list_dec * var compound_stm);
      make (newfuncint', function_def) R.(var declarator * var compound_stm);

      make (nodeclarator', dec) R.(var list_declaration_specifier * text ";");
      make (declarators', dec) R.(var list_declaration_specifier * var list_init_declarator * text ";");

      make (u, list_dec) (var dec);
      make (u, list_dec) R.(var dec * var list_dec);

      make (u, list_declaration_specifier) (var declaration_specifier);
      make (u, list_declaration_specifier) R.(var declaration_specifier * var list_declaration_specifier);

      make (type', declaration_specifier) (var type_specifier);
      make (storage', declaration_specifier) (var storage_class_specifier);
      make (specprop', declaration_specifier) (var type_qualifier);

      make (u, list_init_declarator) (var init_declarator);
      make (u, list_init_declarator) R.(var init_declarator * text "," * var list_init_declarator);

      make (onlydecl', init_declarator) (var declarator);
      make (initdecl', init_declarator) R.(var declarator * text "=" * var initializer_);

      make (tvoid', type_specifier) (var type_void);
      make (tchar', type_specifier) (var type_char);
      make (tshort', type_specifier) (var type_short);
      make (tint', type_specifier) (var type_int);
      make (tlong', type_specifier) (var type_long);
      make (tfloat', type_specifier) (var type_float);
      make (tdouble', type_specifier) (var type_double);
      make (tsigned', type_specifier) (var type_signed);
      make (tunsigned', type_specifier) (var type_unsigned);
      make (tstruct', type_specifier) (var struct_or_union_spec);
      make (tenum', type_specifier) (var enum_specifier);
      make (tname', type_specifier) (var type_typedef);

      make (mytype', storage_class_specifier) (var typedef);
      make (globalprograms', storage_class_specifier) (var extern);
      make (localprogram', storage_class_specifier) (var static);
      make (localblock', storage_class_specifier) (var auto);
      make (localreg', storage_class_specifier) (var register);

      make (const', type_qualifier) (var const);
      make (nooptim', type_qualifier) (var volatile);

      make (tag', struct_or_union_spec) R.(var struct_or_union * var ident * text "{" * var list_struct_dec * text "}");
      make (unique', struct_or_union_spec) R.(var struct_or_union * text "{" * var list_struct_dec * text "}");
      make (tagtype', struct_or_union_spec) R.(var struct_or_union * var ident);

      make (struct', struct_or_union) (var struct_);
      make (union', struct_or_union) (var union);

      make (u, list_struct_dec) (var struct_dec);
      make (u, list_struct_dec) R.(var struct_dec * var list_struct_dec);

      make (structen', struct_dec) R.(var list_spec_qual * var list_struct_declarator * text ";");

      make (u, list_spec_qual) (var spec_qual);
      make (u, list_spec_qual) R.(var spec_qual * var list_spec_qual);

      make (typespec', spec_qual) (var type_specifier);
      make (qualspec', spec_qual) (var type_qualifier);

      make (u, list_struct_declarator) (var struct_declarator);
      make (u, list_struct_declarator) R.(var struct_declarator * text "," * var list_struct_declarator);

      make (decl', struct_declarator) (var declarator);
      make (field', struct_declarator) R.(text ":" * var constant_expression);
      make (decfield', struct_declarator) R.(var declarator * text ":" * var constant_expression);


      make (enumdec', enum_specifier) R.(var enum * text "{" * var list_enumerator * text "}");
      make (enumname', enum_specifier) R.(var enum * var ident * text "{" * var list_enumerator * text "}");
      make (enumvar', enum_specifier) R.(var enum * var ident);

      make (u, list_enumerator) (var enumerator);
      make (u, list_enumerator) R.(var enumerator * text ",");
      make (u, list_enumerator) R.(var enumerator * text "," * var list_enumerator);

      make (plain', enumerator) (var ident);
      make (enuminit', enumerator) R.(var ident * text "=" * var constant_expression);


      make (beginpointer', declarator) R.(var pointer * var direct_declarator);
      make (nopointer', declarator) (var direct_declarator);

      make (name', direct_declarator) (var ident);
      make (parendecl', direct_declarator) R.(text "(" * var declarator * text ")");
      make (innitarray', direct_declarator) R.(var direct_declarator * text "[" * var constant_expression * text "]");
      make (incomplete', direct_declarator) R.(var direct_declarator * text "[" * text "]");
      make (newfuncdec', direct_declarator) R.(var direct_declarator * text "(" * var parameter_type * text ")");
      make (oldfuncdef', direct_declarator) R.(var direct_declarator * text "(" * var list_ident * text ")");
      make (oldfuncdec', direct_declarator) R.(var direct_declarator * text "(" * text ")");

      make (point', pointer) (var pointer);
      make (pointqual', pointer) R.(var pointer * var list_type_qualifier);
      make (pointpoint', pointer) R.(var pointer * var pointer);
      make (pointqualpoint', pointer) R.(var pointer * var list_type_qualifier * var pointer);

      make (u, list_type_qualifier) (var type_qualifier);
      make (u, list_type_qualifier) R.(var type_qualifier * var list_type_qualifier);

      make (allspec', parameter_type) (var parameter_declarations);
      make (more', parameter_type) R.(var parameter_declarations * text "," * text "...");

      make (paramdec', parameter_declarations) (var parameter_declaration);
      make (moreparamdec', parameter_declarations) R.(var parameter_declarations * text "," * var parameter_declaration);

      make (onlytype', parameter_declaration) (var list_declaration_specifier);
      make (typeandparam', parameter_declaration) R.(var list_declaration_specifier * var declarator);
      make (abstract', parameter_declaration) R.(var list_declaration_specifier * var abstract_declarator);

      make (u, list_ident) (var ident);
      make (u, list_ident) R.(var ident * text "," * var list_ident);

      make (initexpr', initializer_) (var exp2);
      make (initlistone', initializer_) R.(text "{" * var initializers * text "}");
      make (initlisttwo', initializer_) R.(text "{" * var initializers * text "," * text "}");

      make (aninit', initializers) (var initializer_);
      make (moreinit', initializers) R.(var initializers * text "," * var initializer_);

      make (plaintype', type_name) (var list_spec_qual);
      make (extendedtype', type_name) R.(var list_spec_qual * var abstract_declarator);

      make (pointerstart', abstract_declarator) (var pointer);
      make (advanced', abstract_declarator) (var dir_abs_dec);
      make (pointadvanced', abstract_declarator) R.(var pointer * var dir_abs_dec);

      make (withinparentes', dir_abs_dec) R.(text "(" * var abstract_declarator * text ")");
      make (array', dir_abs_dec) R.(text "[" * text "]");
      make (initiatedarray', dir_abs_dec) R.(text "[" * var constant_expression * text "]");
      make (uninitiated', dir_abs_dec) R.(var dir_abs_dec * text "[" * text "]");
      make (initiated', dir_abs_dec) R.(var dir_abs_dec * text "[" * var constant_expression * text "]");
      make (oldfunction', dir_abs_dec) R.(text "(" * text ")");
      make (newfunction', dir_abs_dec) R.(text "(" * var parameter_type * text ")");
      make (oldfuncexpr', dir_abs_dec) R.(var dir_abs_dec * text "(" * text ")");
      make (newfuncexpr', dir_abs_dec) R.(var dir_abs_dec * text "(" * var parameter_type * text ")");

      make (labels', stm) (var labeled_stm);
      make (comps', stm) (var compound_stm);
      make (exprs', stm) (var expression_stm);
      make (sels', stm) (var selection_stm);
      make (iters', stm) (var iter_stm);
      make (jumps', stm) (var jump_stm);

      make (slabelone', labeled_stm) R.(var ident * text ":" * var stm);
      make (slabeltwo', labeled_stm) R.(var case * var constant_expression * text ":" * var stm);
      make (slabelthree', labeled_stm) R.(var default * text ":" * var stm);

      make (scompone', compound_stm) R.(text "{" * text "}");
      make (scomptwo', compound_stm) R.(text "{" * var list_stm * text "}");
      make (scompthree', compound_stm) R.(text "{" * var list_dec * text "}");
      make (scompfour', compound_stm) R.(text "{" * var list_dec * var list_stm * text "}");

      make (sexprone', expression_stm) (text ";");
      make (sexprtwo', expression_stm) R.(var exp * text ";");

      make (sselone', selection_stm) R.(var if_ * text "(" * var exp * text ")" * var stm);
      make (sseltwo', selection_stm) R.(var if_ * text "(" * var exp * text ")" * var stm * var else_ * var stm);
      make (sselthree', selection_stm) R.(var switch * text "(" * var exp * text ")" * var stm);

      make (siterone', iter_stm) R.(var while_ * text "(" * var exp * text ")" * var stm);
      make (sitertwo', iter_stm) R.(var do_ * var stm * var while_ * text "(" * var exp * text ")" * text ";");
      make (siterthree', iter_stm) R.(var for_ * text "(" * var expression_stm * var expression_stm * text ")" * var stm);
      make (siterfour', iter_stm) R.(var for_ * text "(" * var expression_stm * var expression_stm * var exp * text ")" * var stm);

      make (sjumpone', jump_stm) R.(var goto * var ident * text ";");
      make (sjumptwo', jump_stm) R.(var continue * text ";");
      make (sjumpthree', jump_stm) R.(var break * text ";");
      make (sjumpfour', jump_stm) R.(var return * text ";");
      make (sjumpfive', jump_stm) R.(var return * var exp * text ";");

      make (u, list_stm) (var stm);
      make (u, list_stm) R.(var stm * var list_stm);

      make (ecomma', exp) R.(var exp * text "," * var exp2);
      make (eassign', exp2) R.(var exp15 * var assignment_op * var exp2);
      make (econdition', exp3) R.(var exp4 * var ternary_if * var exp * var ternary_else * var exp3);
      make (elor', exp4) R.(var exp4 * text "||" * var exp5);
      make (eland', exp5) R.(var exp5 * text "&&" * var exp6);
      make (ebitor', exp6) R.(var exp6 * text "|" * var exp7);
      make (ebitexor', exp7) R.(var exp7 * text "^" * var exp8);
      make (ebitand', exp8) R.(var exp8 * text "&" * var exp9);
      make (eeq', exp9) R.(var exp9 * text "==" * var exp10);
      make (eneq', exp9) R.(var exp9 * text "!=" * var exp10);
      make (elthen', exp10) R.(var exp10 * text "<" * var exp11);
      make (egrthen', exp10) R.(var exp10 * text ">" * var exp11);
      make (ele', exp10) R.(var exp10 * text "<=" * var exp11);
      make (ege', exp10) R.(var exp10 * text ">=" * var exp11);
      make (eleft', exp11) R.(var exp11 * text "<<" * var exp12);
      make (eright', exp11) R.(var exp11 * text ">>" * var exp12);
      make (eplus', exp12) R.(var exp12 * text "+" * var exp13);
      make (eminus', exp12) R.(var exp12 * text "-" * var exp13);
      make (etimes', exp13) R.(var exp13 * text "*" * var exp14);
      make (ediv', exp13) R.(var exp13 * text "/" * var exp14);
      make (emod', exp13) R.(var exp13 * text "%" * var exp14);
      make (etypeconv', exp14) R.(text "(" * var type_name * text ")" * var exp14);
      make (epreinc', exp15) R.(text "++" * var exp15);
      make (epredec', exp15) R.(text "--" * var exp15);
      make (epreop', exp15) R.(var unary_operator * var exp14);
      make (ebytesexpr', exp15) R.(var sizeof * var exp15);
      make (ebytestype', exp15) R.(var sizeof * text "(" * var type_name * text ")");
      make (earray', exp16) R.(var exp16 * text "[" * var exp * text "]");
      make (efunk', exp16) R.(var exp16 * text "(" * text ")");
      make (efunkpar', exp16) R.(var exp16 * text "(" * var list_exp2 * text ")");
      make (eselect', exp16) R.(var exp16 * text "." * var ident);
      make (epoint', exp16) R.(var exp16 * text "->" * var ident);
      make (epostinc', exp16) R.(var exp16 * text "++");
      make (epostdec', exp16) R.(var exp16 * text "--");
      make (evar', exp17) (var ident);
      make (econst', exp17) (var constant);
      make (estring', exp17) (var string);

      make (echar', constant) (var char);
      make (eunsigned', constant) (var unsigned);
      make (elong', constant) (var long);
      make (eunsignlong', constant) (var unsignedlong);
      make (ehexadec', constant) (var hexadecimal);
      make (ehexaunsign', constant) (var hexunsigned);
      make (ehexalong', constant) (var hexlong);
      make (ehexaunslong', constant) (var hexunslong);
      make (eoctal', constant) (var octal);
      make (eoctalunsign', constant) (var octalunsigned);
      make (eoctallong', constant) (var octallong);
      make (eoctalunslong', constant) (var octalunslong);
      make (edouble', constant) (var double);
      make (efloat', constant) (var float);
      make (elongdouble', constant) (var longdouble);
      make (eint', constant) (var integer);

      make (especial', constant_expression) (var exp3);

      make (u, list_exp2) (var exp2);
      make (u, list_exp2) R.(var exp2 * text "," * var list_exp2);

      make (u, exp) (var exp2);
      make (u, exp2) (var exp3);
      make (u, exp3) (var exp4);
      make (u, exp4) (var exp5);
      make (u, exp5) (var exp6);
      make (u, exp6) (var exp7);
      make (u, exp7) (var exp8);
      make (u, exp8) (var exp9);
      make (u, exp9) (var exp10);
      make (u, exp10) (var exp11);
      make (u, exp11) (var exp12);
      make (u, exp12) (var exp13);
      make (u, exp13) (var exp14);
      make (u, exp14) (var exp15);
      make (u, exp15) (var exp16);
      make (u, exp16) (var exp17);
      make (u, exp17) R.(text "(" * var exp * text ")");

      make (address', unary_operator) (var address);
      make (indirection', unary_operator) (var indirection);
      make (plus', unary_operator) (text "+");
      make (negative', unary_operator) (text "-");
      make (complement', unary_operator) (var bitcomp);
      make (logicalneg', unary_operator) (var lneg);

      make (assign', assignment_op) (text "=");
      make (assignmul', assignment_op) (text "*=");
      make (assigndiv', assignment_op) (text "/=");
      make (assignmod', assignment_op) (text "%=");
      make (assignadd', assignment_op) (text "+=");
      make (assignsub', assignment_op) (text "-=");
      make (assignleft', assignment_op) (text "<<=");
      make (assignright', assignment_op) (text ">>=");
      make (assignand', assignment_op) (text "&=");
      make (assignxor', assignment_op) (text "^=");
      make (assignor', assignment_op) (text "|=");
    ]

  let scanner =
    let letter = R.(range "A" "Z" + range "a" "z" + codes "_") in
    let digit = range "0" "9" in
    let ident_ = R.(letter * star (letter + digit)) in
    let nzdigit = range "1" "9" in
    let hexdigit = R.(range "a" "f" + range "A" "F") in
    let octdigit = range "0" "7" in
    let integer_ = R.(nzdigit * star digit) in
    let hexdecimal_ = R.(codes "0" * codes "xX" * plus (digit + hexdigit)) in
    let octal_ = R.(codes "0" * star octdigit) in
    let double_ = R.(((star digit * codes "." * plus digit) + (plus digit * codes ".")) * (opt (codes "eE" * opt (codes "+-") * plus digit)) + plus digit * codes "eE" * opt (codes "+-") * plus digit) in
    Production.[
      make (u, ident) ident_;
      make (u, string) R.(codes "\"" * (not_codes "\"\\" + codes "\\" * any) * codes "\"");
      make (u, char) R.(codes "'" * (not_codes "'\\" + codes "\\" * any) * codes "'");
      make (u, integer) integer_;
      make (u, unsigned) R.(integer_ * codes "uU");
      make (u, long) R.(integer_ * codes "lL");
      make (u, unsignedlong) R.(integer_ * (text "ul" * text "UL"));
      make (u, hexadecimal) hexdecimal_;
      make (u, hexunsigned) R.(hexdecimal_ * codes "uU");
      make (u, hexlong) R.(hexdecimal_ * codes "lL");
      make (u, hexunslong) R.(hexdecimal_ * (text "ul" * text "UL"));
      make (u, octal) octal_;
      make (u, octalunsigned) R.(octal_ * codes "uU");
      make (u, octallong) R.(octal_ * codes "lL");
      make (u, octalunslong) R.(octal_ * (text "ul" * text "UL"));
      make (u, double) double_;
      make (u, float) R.(double_ * codes "fF");
      make (u, longdouble) R.(double_ * codes "lL");

      make (u, type_void) (text "void");
      make (u, type_char) (text "char");
      make (u, type_short) (text "short");
      make (u, type_int) (text "int");
      make (u, type_long) (text "long");
      make (u, type_float) (text "float");
      make (u, type_double) (text "double");
      make (u, type_signed) (text "signed");
      make (u, type_unsigned) (text "unsigned");
      make (u, type_typedef) ident_;

      make (u, typedef) (text "typedef");
      make (u, extern) (text "extern");
      make (u, static) (text "static");
      make (u, auto) (text "auto");
      make (u, register) (text "register");
      make (u, const) (text "const");
      make (u, volatile) (text "volatile");
      make (u, struct_) (text "struct");
      make (u, union) (text "union");
      make (u, enum) (text "enum");
      make (u, case) (text "case");
      make (u, default) (text "default");
      make (u, if_) (text "if");
      make (u, else_) (text "else");
      make (u, switch) (text "switch");
      make (u, while_) (text "while");
      make (u, do_) (text "do");
      make (u, for_) (text "for");
      make (u, goto) (text "goto");
      make (u, continue) (text "continue");
      make (u, break) (text "break");
      make (u, return) (text "return");
      make (u, sizeof) (text "sizeof");

      make (u, ternary_if) (codes "?");
      make (u, ternary_else) (codes ":");
      make (u, address) (codes "&");
      make (u, indirection) (codes "*");
      make (u, pointer) (codes "*");
      make (u, bitcomp) (codes "~");
      make (u, lneg) (codes "!");

      make (u, ws) R.(star (codes " \n\r\t"));
    ]

end)

let _ =
  let d = X.driver () in
  X.Run.file (fun c -> d#read c) "test.c";
  Fmt.pr "@[%s@]" (Dot.string_of_graph d#to_dot);
  Fmt.pr "@[%s@]" (Dot.string_of_graph (T.Node_packed_forest.to_dot d#forest))
